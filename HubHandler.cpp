// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Hub.h"
#include "Node.h"
#include "HubHandler.h"
#include "settings.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/server/TNonblockingServer.h>
#include "NodeClient.h"

using namespace apache::thrift;
using namespace apache::thrift::protocol;
using namespace apache::thrift::transport;
using namespace apache::thrift::server;
using namespace apache::thrift::concurrency;
using namespace mp3;

using boost::shared_ptr;

HubHandler::HubHandler() {}
HubHandler::~HubHandler() {}

void HubHandler::join(const int16_t port) {
  m_mutex.lock();
  DEBUG("Adding node " << port << " to the group.");


  nodeMap.insert(std::make_pair(port, boost::shared_ptr<NodeIf>(new SimpleNodeClient(port))));

  for(boost::unordered_map<int, boost::shared_ptr<NodeIf> >::iterator iterator = nodeMap.begin(); iterator != nodeMap.end(); iterator++) {
    if(iterator->first == port){
      for(boost::unordered_map<int, boost::shared_ptr<NodeIf> >::iterator iterator2 = nodeMap.begin(); iterator2 != nodeMap.end(); iterator2++) {
        DEBUG("Notifying node " << iterator->first << " that port " << iterator2->first << " was already joined.");
        iterator->second->joinNotify(iterator2->first);
      }
    }
    else{
      DEBUG("Notifying node " << iterator->first << " that port " << port << " has joined.");
      iterator->second->joinNotify(port);
    }
  }

  m_mutex.unlock();
}

void HubHandler::leave(const int16_t port) {
  m_mutex.lock();
  DEBUG("Removing node " << port << " from the group.");
  nodeMap.erase(port);

  for(boost::unordered_map<int, boost::shared_ptr<NodeIf> >::iterator iterator = nodeMap.begin(); iterator != nodeMap.end(); iterator++) {
    DEBUG("Notifying node " << iterator->first << " that port " << port << " has left.");
    iterator->second->leaveNotify(port);
  }
  m_mutex.unlock();
}

void HubHandler::getMembers(std::vector<int16_t> & _return){
  m_mutex.lock();
  _return.clear();
  for(boost::unordered_map<int, boost::shared_ptr<NodeIf> >::iterator iterator = nodeMap.begin(); iterator != nodeMap.end(); iterator++) {
    _return.push_back(iterator->first);
  }
  m_mutex.unlock();
}

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<HubHandler> handler(new HubHandler());
  shared_ptr<TProcessor> processor(new HubProcessor(handler));
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(15);
  shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();
  shared_ptr<TNonblockingServer> server(new  TNonblockingServer(processor, protocolFactory, port, threadManager));
  server->serve();
  return 0;
}

