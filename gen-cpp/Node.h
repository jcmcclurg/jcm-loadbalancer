/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Node_H
#define Node_H

#include <thrift/TDispatchProcessor.h>
#include "node_types.h"

namespace mp3 {

class NodeIf {
 public:
  virtual ~NodeIf() {}
  virtual void joinNotify(const int16_t port) = 0;
  virtual void leaveNotify(const int16_t port) = 0;
  virtual int16_t getNumJobs() = 0;
  virtual void queueJob(const Job& job) = 0;
  virtual void processJobs(std::vector<Result> & _return) = 0;
  virtual void setBatchSize(const int16_t size) = 0;
  virtual int16_t getNumExtraJobs() = 0;
  virtual void giveJobs(std::vector<Job> & _return, const int16_t numJobs) = 0;
  virtual void notifyMutexRequest(const int16_t lamportTs, const int16_t fromPort) = 0;
  virtual void notifyMutexReply(const int16_t fromPort) = 0;
};

class NodeIfFactory {
 public:
  typedef NodeIf Handler;

  virtual ~NodeIfFactory() {}

  virtual NodeIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(NodeIf* /* handler */) = 0;
};

class NodeIfSingletonFactory : virtual public NodeIfFactory {
 public:
  NodeIfSingletonFactory(const boost::shared_ptr<NodeIf>& iface) : iface_(iface) {}
  virtual ~NodeIfSingletonFactory() {}

  virtual NodeIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(NodeIf* /* handler */) {}

 protected:
  boost::shared_ptr<NodeIf> iface_;
};

class NodeNull : virtual public NodeIf {
 public:
  virtual ~NodeNull() {}
  void joinNotify(const int16_t /* port */) {
    return;
  }
  void leaveNotify(const int16_t /* port */) {
    return;
  }
  int16_t getNumJobs() {
    int16_t _return = 0;
    return _return;
  }
  void queueJob(const Job& /* job */) {
    return;
  }
  void processJobs(std::vector<Result> & /* _return */) {
    return;
  }
  void setBatchSize(const int16_t /* size */) {
    return;
  }
  int16_t getNumExtraJobs() {
    int16_t _return = 0;
    return _return;
  }
  void giveJobs(std::vector<Job> & /* _return */, const int16_t /* numJobs */) {
    return;
  }
  void notifyMutexRequest(const int16_t /* lamportTs */, const int16_t /* fromPort */) {
    return;
  }
  void notifyMutexReply(const int16_t /* fromPort */) {
    return;
  }
};

typedef struct _Node_joinNotify_args__isset {
  _Node_joinNotify_args__isset() : port(false) {}
  bool port;
} _Node_joinNotify_args__isset;

class Node_joinNotify_args {
 public:

  Node_joinNotify_args() : port(0) {
  }

  virtual ~Node_joinNotify_args() throw() {}

  int16_t port;

  _Node_joinNotify_args__isset __isset;

  void __set_port(const int16_t val) {
    port = val;
  }

  bool operator == (const Node_joinNotify_args & rhs) const
  {
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const Node_joinNotify_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_joinNotify_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_joinNotify_pargs {
 public:


  virtual ~Node_joinNotify_pargs() throw() {}

  const int16_t* port;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_leaveNotify_args__isset {
  _Node_leaveNotify_args__isset() : port(false) {}
  bool port;
} _Node_leaveNotify_args__isset;

class Node_leaveNotify_args {
 public:

  Node_leaveNotify_args() : port(0) {
  }

  virtual ~Node_leaveNotify_args() throw() {}

  int16_t port;

  _Node_leaveNotify_args__isset __isset;

  void __set_port(const int16_t val) {
    port = val;
  }

  bool operator == (const Node_leaveNotify_args & rhs) const
  {
    if (!(port == rhs.port))
      return false;
    return true;
  }
  bool operator != (const Node_leaveNotify_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_leaveNotify_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_leaveNotify_pargs {
 public:


  virtual ~Node_leaveNotify_pargs() throw() {}

  const int16_t* port;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_getNumJobs_args {
 public:

  Node_getNumJobs_args() {
  }

  virtual ~Node_getNumJobs_args() throw() {}


  bool operator == (const Node_getNumJobs_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Node_getNumJobs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_getNumJobs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_getNumJobs_pargs {
 public:


  virtual ~Node_getNumJobs_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_getNumJobs_result__isset {
  _Node_getNumJobs_result__isset() : success(false) {}
  bool success;
} _Node_getNumJobs_result__isset;

class Node_getNumJobs_result {
 public:

  Node_getNumJobs_result() : success(0) {
  }

  virtual ~Node_getNumJobs_result() throw() {}

  int16_t success;

  _Node_getNumJobs_result__isset __isset;

  void __set_success(const int16_t val) {
    success = val;
  }

  bool operator == (const Node_getNumJobs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Node_getNumJobs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_getNumJobs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_getNumJobs_presult__isset {
  _Node_getNumJobs_presult__isset() : success(false) {}
  bool success;
} _Node_getNumJobs_presult__isset;

class Node_getNumJobs_presult {
 public:


  virtual ~Node_getNumJobs_presult() throw() {}

  int16_t* success;

  _Node_getNumJobs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Node_queueJob_args__isset {
  _Node_queueJob_args__isset() : job(false) {}
  bool job;
} _Node_queueJob_args__isset;

class Node_queueJob_args {
 public:

  Node_queueJob_args() {
  }

  virtual ~Node_queueJob_args() throw() {}

  Job job;

  _Node_queueJob_args__isset __isset;

  void __set_job(const Job& val) {
    job = val;
  }

  bool operator == (const Node_queueJob_args & rhs) const
  {
    if (!(job == rhs.job))
      return false;
    return true;
  }
  bool operator != (const Node_queueJob_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_queueJob_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_queueJob_pargs {
 public:


  virtual ~Node_queueJob_pargs() throw() {}

  const Job* job;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_processJobs_args {
 public:

  Node_processJobs_args() {
  }

  virtual ~Node_processJobs_args() throw() {}


  bool operator == (const Node_processJobs_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Node_processJobs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_processJobs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_processJobs_pargs {
 public:


  virtual ~Node_processJobs_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_processJobs_result__isset {
  _Node_processJobs_result__isset() : success(false), e(false) {}
  bool success;
  bool e;
} _Node_processJobs_result__isset;

class Node_processJobs_result {
 public:

  Node_processJobs_result() {
  }

  virtual ~Node_processJobs_result() throw() {}

  std::vector<Result>  success;
  MyError e;

  _Node_processJobs_result__isset __isset;

  void __set_success(const std::vector<Result> & val) {
    success = val;
  }

  void __set_e(const MyError& val) {
    e = val;
  }

  bool operator == (const Node_processJobs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(e == rhs.e))
      return false;
    return true;
  }
  bool operator != (const Node_processJobs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_processJobs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_processJobs_presult__isset {
  _Node_processJobs_presult__isset() : success(false), e(false) {}
  bool success;
  bool e;
} _Node_processJobs_presult__isset;

class Node_processJobs_presult {
 public:


  virtual ~Node_processJobs_presult() throw() {}

  std::vector<Result> * success;
  MyError e;

  _Node_processJobs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Node_setBatchSize_args__isset {
  _Node_setBatchSize_args__isset() : size(false) {}
  bool size;
} _Node_setBatchSize_args__isset;

class Node_setBatchSize_args {
 public:

  Node_setBatchSize_args() : size(0) {
  }

  virtual ~Node_setBatchSize_args() throw() {}

  int16_t size;

  _Node_setBatchSize_args__isset __isset;

  void __set_size(const int16_t val) {
    size = val;
  }

  bool operator == (const Node_setBatchSize_args & rhs) const
  {
    if (!(size == rhs.size))
      return false;
    return true;
  }
  bool operator != (const Node_setBatchSize_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_setBatchSize_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_setBatchSize_pargs {
 public:


  virtual ~Node_setBatchSize_pargs() throw() {}

  const int16_t* size;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_getNumExtraJobs_args {
 public:

  Node_getNumExtraJobs_args() {
  }

  virtual ~Node_getNumExtraJobs_args() throw() {}


  bool operator == (const Node_getNumExtraJobs_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Node_getNumExtraJobs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_getNumExtraJobs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_getNumExtraJobs_pargs {
 public:


  virtual ~Node_getNumExtraJobs_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_getNumExtraJobs_result__isset {
  _Node_getNumExtraJobs_result__isset() : success(false) {}
  bool success;
} _Node_getNumExtraJobs_result__isset;

class Node_getNumExtraJobs_result {
 public:

  Node_getNumExtraJobs_result() : success(0) {
  }

  virtual ~Node_getNumExtraJobs_result() throw() {}

  int16_t success;

  _Node_getNumExtraJobs_result__isset __isset;

  void __set_success(const int16_t val) {
    success = val;
  }

  bool operator == (const Node_getNumExtraJobs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Node_getNumExtraJobs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_getNumExtraJobs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_getNumExtraJobs_presult__isset {
  _Node_getNumExtraJobs_presult__isset() : success(false) {}
  bool success;
} _Node_getNumExtraJobs_presult__isset;

class Node_getNumExtraJobs_presult {
 public:


  virtual ~Node_getNumExtraJobs_presult() throw() {}

  int16_t* success;

  _Node_getNumExtraJobs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Node_giveJobs_args__isset {
  _Node_giveJobs_args__isset() : numJobs(false) {}
  bool numJobs;
} _Node_giveJobs_args__isset;

class Node_giveJobs_args {
 public:

  Node_giveJobs_args() : numJobs(0) {
  }

  virtual ~Node_giveJobs_args() throw() {}

  int16_t numJobs;

  _Node_giveJobs_args__isset __isset;

  void __set_numJobs(const int16_t val) {
    numJobs = val;
  }

  bool operator == (const Node_giveJobs_args & rhs) const
  {
    if (!(numJobs == rhs.numJobs))
      return false;
    return true;
  }
  bool operator != (const Node_giveJobs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_giveJobs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_giveJobs_pargs {
 public:


  virtual ~Node_giveJobs_pargs() throw() {}

  const int16_t* numJobs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_giveJobs_result__isset {
  _Node_giveJobs_result__isset() : success(false) {}
  bool success;
} _Node_giveJobs_result__isset;

class Node_giveJobs_result {
 public:

  Node_giveJobs_result() {
  }

  virtual ~Node_giveJobs_result() throw() {}

  std::vector<Job>  success;

  _Node_giveJobs_result__isset __isset;

  void __set_success(const std::vector<Job> & val) {
    success = val;
  }

  bool operator == (const Node_giveJobs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Node_giveJobs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_giveJobs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_giveJobs_presult__isset {
  _Node_giveJobs_presult__isset() : success(false) {}
  bool success;
} _Node_giveJobs_presult__isset;

class Node_giveJobs_presult {
 public:


  virtual ~Node_giveJobs_presult() throw() {}

  std::vector<Job> * success;

  _Node_giveJobs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Node_notifyMutexRequest_args__isset {
  _Node_notifyMutexRequest_args__isset() : lamportTs(false), fromPort(false) {}
  bool lamportTs;
  bool fromPort;
} _Node_notifyMutexRequest_args__isset;

class Node_notifyMutexRequest_args {
 public:

  Node_notifyMutexRequest_args() : lamportTs(0), fromPort(0) {
  }

  virtual ~Node_notifyMutexRequest_args() throw() {}

  int16_t lamportTs;
  int16_t fromPort;

  _Node_notifyMutexRequest_args__isset __isset;

  void __set_lamportTs(const int16_t val) {
    lamportTs = val;
  }

  void __set_fromPort(const int16_t val) {
    fromPort = val;
  }

  bool operator == (const Node_notifyMutexRequest_args & rhs) const
  {
    if (!(lamportTs == rhs.lamportTs))
      return false;
    if (!(fromPort == rhs.fromPort))
      return false;
    return true;
  }
  bool operator != (const Node_notifyMutexRequest_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_notifyMutexRequest_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_notifyMutexRequest_pargs {
 public:


  virtual ~Node_notifyMutexRequest_pargs() throw() {}

  const int16_t* lamportTs;
  const int16_t* fromPort;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Node_notifyMutexReply_args__isset {
  _Node_notifyMutexReply_args__isset() : fromPort(false) {}
  bool fromPort;
} _Node_notifyMutexReply_args__isset;

class Node_notifyMutexReply_args {
 public:

  Node_notifyMutexReply_args() : fromPort(0) {
  }

  virtual ~Node_notifyMutexReply_args() throw() {}

  int16_t fromPort;

  _Node_notifyMutexReply_args__isset __isset;

  void __set_fromPort(const int16_t val) {
    fromPort = val;
  }

  bool operator == (const Node_notifyMutexReply_args & rhs) const
  {
    if (!(fromPort == rhs.fromPort))
      return false;
    return true;
  }
  bool operator != (const Node_notifyMutexReply_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Node_notifyMutexReply_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Node_notifyMutexReply_pargs {
 public:


  virtual ~Node_notifyMutexReply_pargs() throw() {}

  const int16_t* fromPort;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

class NodeClient : virtual public NodeIf {
 public:
  NodeClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  NodeClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void joinNotify(const int16_t port);
  void send_joinNotify(const int16_t port);
  void leaveNotify(const int16_t port);
  void send_leaveNotify(const int16_t port);
  int16_t getNumJobs();
  void send_getNumJobs();
  int16_t recv_getNumJobs();
  void queueJob(const Job& job);
  void send_queueJob(const Job& job);
  void processJobs(std::vector<Result> & _return);
  void send_processJobs();
  void recv_processJobs(std::vector<Result> & _return);
  void setBatchSize(const int16_t size);
  void send_setBatchSize(const int16_t size);
  int16_t getNumExtraJobs();
  void send_getNumExtraJobs();
  int16_t recv_getNumExtraJobs();
  void giveJobs(std::vector<Job> & _return, const int16_t numJobs);
  void send_giveJobs(const int16_t numJobs);
  void recv_giveJobs(std::vector<Job> & _return);
  void notifyMutexRequest(const int16_t lamportTs, const int16_t fromPort);
  void send_notifyMutexRequest(const int16_t lamportTs, const int16_t fromPort);
  void notifyMutexReply(const int16_t fromPort);
  void send_notifyMutexReply(const int16_t fromPort);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class NodeProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<NodeIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (NodeProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_joinNotify(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_leaveNotify(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNumJobs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_queueJob(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_processJobs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setBatchSize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getNumExtraJobs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_giveJobs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_notifyMutexRequest(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_notifyMutexReply(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  NodeProcessor(boost::shared_ptr<NodeIf> iface) :
    iface_(iface) {
    processMap_["joinNotify"] = &NodeProcessor::process_joinNotify;
    processMap_["leaveNotify"] = &NodeProcessor::process_leaveNotify;
    processMap_["getNumJobs"] = &NodeProcessor::process_getNumJobs;
    processMap_["queueJob"] = &NodeProcessor::process_queueJob;
    processMap_["processJobs"] = &NodeProcessor::process_processJobs;
    processMap_["setBatchSize"] = &NodeProcessor::process_setBatchSize;
    processMap_["getNumExtraJobs"] = &NodeProcessor::process_getNumExtraJobs;
    processMap_["giveJobs"] = &NodeProcessor::process_giveJobs;
    processMap_["notifyMutexRequest"] = &NodeProcessor::process_notifyMutexRequest;
    processMap_["notifyMutexReply"] = &NodeProcessor::process_notifyMutexReply;
  }

  virtual ~NodeProcessor() {}
};

class NodeProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  NodeProcessorFactory(const ::boost::shared_ptr< NodeIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< NodeIfFactory > handlerFactory_;
};

class NodeMultiface : virtual public NodeIf {
 public:
  NodeMultiface(std::vector<boost::shared_ptr<NodeIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~NodeMultiface() {}
 protected:
  std::vector<boost::shared_ptr<NodeIf> > ifaces_;
  NodeMultiface() {}
  void add(boost::shared_ptr<NodeIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void joinNotify(const int16_t port) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->joinNotify(port);
    }
    ifaces_[i]->joinNotify(port);
  }

  void leaveNotify(const int16_t port) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->leaveNotify(port);
    }
    ifaces_[i]->leaveNotify(port);
  }

  int16_t getNumJobs() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNumJobs();
    }
    return ifaces_[i]->getNumJobs();
  }

  void queueJob(const Job& job) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->queueJob(job);
    }
    ifaces_[i]->queueJob(job);
  }

  void processJobs(std::vector<Result> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->processJobs(_return);
    }
    ifaces_[i]->processJobs(_return);
    return;
  }

  void setBatchSize(const int16_t size) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setBatchSize(size);
    }
    ifaces_[i]->setBatchSize(size);
  }

  int16_t getNumExtraJobs() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getNumExtraJobs();
    }
    return ifaces_[i]->getNumExtraJobs();
  }

  void giveJobs(std::vector<Job> & _return, const int16_t numJobs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->giveJobs(_return, numJobs);
    }
    ifaces_[i]->giveJobs(_return, numJobs);
    return;
  }

  void notifyMutexRequest(const int16_t lamportTs, const int16_t fromPort) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->notifyMutexRequest(lamportTs, fromPort);
    }
    ifaces_[i]->notifyMutexRequest(lamportTs, fromPort);
  }

  void notifyMutexReply(const int16_t fromPort) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->notifyMutexReply(fromPort);
    }
    ifaces_[i]->notifyMutexReply(fromPort);
  }

};

} // namespace

#endif
